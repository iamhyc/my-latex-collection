\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{braket}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage[normalem]{ulem} % for strikeout line
% \usepackage{graphicx}
% \usepackage{epstopdf}

%-------------------------------------------------------%
\newcounter{pcounter}                                   %
\newenvironment{problem}                                %
{                                                       %
    \color{gray}                                        %
    \stepcounter{pcounter}                              %
    \textbf{\arabic{pcounter}.}                         %
}{}                                                     %
\newenvironment{solution}                               %
{\textbf{Solution:} \\}{$\blacksquare$\newline}         %
%-------------------------------------------------------%
\newcommand{\tab}{\ \ \ \ }                             %
\newcommand{\leadto}{\Rightarrow}                       %
\newcommand{\domR}{\mathbb{R}}                          %
\newcommand{\domS}{\mathbb{S}}                          %
\newcommand{\abss}[1]{\| #1 \|}                         %
\newcommand{\tr}[1]{\textbf{tr}(#1)}                    %
\newcommand{\vecOne}{\textbf{1}}                        %
%-------------------------------------------------------%

\begin{document}
    %------------------- The Title -------------------%
    \parindent 0in
    \parskip 1em
    \title{COMP8802 Assignment 2 Solution Sheet}
    \author{3030058647, HONG Yuncong}
    \maketitle

    %=================== Problem 1 ===================%
    \begin{problem}
        Let S=$acggtcgt$ and T=$acctgtt$. Define V[i,j] as the edit distance between S[1..i] and T[1..j]; s[1..0] (T[1..0]) as empty string; and V[0, 0] = 0. Show all entries in the V table and give the edit distance between S and T.
    \end{problem}

    \begin{solution}
        As string S is of length 8 and string T of length 7, the V[i, j] matrix is of size 8*7;
        And the edit distance of each entries are following:
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
                \hline
                  &         $\epsilon$  & a & c & c & t & g & t & t \\ \hline
                $\epsilon$& 0           & -1& -2& -3& -4& -5& -6& -7\\ \hline
                a         & -1          & 2 & 1 & 0 & -1& -2& -3& -4\\ \hline
                c         & -2          & 1 & 4 & 3 & 2 & 1 & 0 & -1 \\ \hline
                g         & -3          & 0 & 3 & 3 & 2 & 4 & 3 & 2 \\ \hline
                g         & -4          & -1& 2 & 2 & 2 & 4 & 3 & 2 \\ \hline
                t         & -5          & -2& 1 & 1 & 4 & 3 & 6 & 5 \\ \hline
                c         & -6          & -3& 0 & 3 & 3 & 3 & 5 & 5 \\ \hline
                g         & -7          & -4& -1& 2 & 2 & 5 & 4 & 4 \\ \hline
                t         & -8          & -5& -2& 1 & 4 & 4 & 7 & 6 \\ \hline
            \end{tabular}
        \end{center}
    \end{solution}

    %=================== Problem 2 ===================%
    \begin{problem}
        Design an OT${^3}_1$ (oblivious transfer) protocol such that Alice has three messages m$_1$, m$_2$ and m$_3$.
        She wants to let Bob obtain \underline{exactly one} of the messages with requirements that: Alice does not know which message Bob selects and Bob cannot know any information about the meesages except the one he selects.
        Show all steps of the protocol (You do NOT need to argue that the protocol satisfies the requirements).
        \\
        Bonus: Can you extend it to an OT${^3}_2$ protocol, i.e., Alice wants to let Bob obtain exactly two of the messages with the same security requirements?
    \end{problem}

    \begin{solution}
        The design for OT${^3}_1$ protocol:
        \begin{enumerate}
            \item Alice generates a RSA key pair comprising $(n, e, d)$, and 3 random numbers: $x_0, x_1, x_2$;
            \item Alice sends Bob 3 random numbers and the public key: $x_0, x_1, x_2, (n, e)$;
            \item Bob chooses the message he wants with $b=0,1,2$, and sends back to Alice the blinded $x_b$ with randomly generated $k$: $v = (x_b + k^e) \mod{n}$
            \item Alice calculates $k_{b'} = (v - x_{b'})^d \mod{n}$ for all the random number, and sends all the message blinded with $k_{b'}$ to Bob as: $m_{b'} + k_{b'}$;
            \item Bob could only figure out the message he chosen with $b' = b$ and easily obtain the message he chosen (and he could not figure out other message as $k_{b' \neq b}$ is random number for him).
        \end{enumerate}
    \end{solution}

    %=================== Problem 3 ===================%
    \begin{problem}
        Let S and T be DNA strings (strings with characters \{a, c, g, t\}) of 3 characters.
        Alice holds S and Bob holds T. If we want to use the secure pattern matching protocol discussed in the lecture (Protocol 1, i.e., Alice creates a garbled circuit for the edit distance of S and T and passes it to Bob) to compute the edit distance of S and T;
        Answer the following questiongs (NO NEED to explain your answers).
        \\
        \begin{enumerate}[label=(\alph*)]
            \item How many input bits are required?
            \item Provide an encoding of the characters \{a, c, g, t\}.
            \item What are the possible values for the edit distance?
            \item How many output bits are required?
            \item What is the number of rows in the truth table for computing the edit distance of S and T?
            \item How many encryptions Alice has to do?
            \item How many random numbers Alice has to generate?
            \item How many random numbers Alice has to pass to Bob?
            \item How many OT${^2}_1$ oblivious tansfer protocols they have to execute?
            \item How many decryptions Bob has to do?
        \end{enumerate}
    \end{problem}

    \begin{solution}
        \begin{enumerate}[label=(\alph*)]
            \item Input required: 3*2*2 = 12 bits;
            \item a='00', c='01', g='10', 't'='11';
            \item maximum similarity scores 6, minimum similarity scores -3 (match with scoring 2, otherwise -1); the possible values range is [-3, 6];
            \item Output required: 4 bits;
            \item Number of rows: $2^{12} = 4096$ rows;
            \item Alice has to carry out $4096x8x4=131072$ encryptions;
            \item Alice has to generate $12*2*3=72$ random numbers;
            \item Alice has to pass $(6+6*2)*3=54$ random numbers to Bob;
            \item OT${^2}_1$ oblivious transfer have to be excuted $6$ times;
            \item Bob has to carry out $131072$ decryptions.
        \end{enumerate}
    \end{solution}

    %=================== Problem 4 ===================%
    \begin{problem}
        Provide the whole truth table for the equality circuit discussed in the lecture (Slide 37) for the secure string matching problem.
    \end{problem}

    \begin{solution}
        \begin{center}
            \begin{tabular}{c|c|c}
                S[i]    &   T[j]    &   $\delta$(S[i], T[j]) \\ \hline
                00      &   00      &   1 \\
                00      &   01      &   0 \\
                00      &   10      &   0 \\
                00      &   11      &   0 \\ \hline
                01      &   00      &   0 \\
                01      &   01      &   1 \\
                01      &   10      &   0 \\
                01      &   11      &   0 \\ \hline
                10      &   00      &   0 \\
                10      &   01      &   0 \\
                10      &   10      &   1 \\
                10      &   11      &   0 \\ \hline
                11      &   00      &   0 \\
                11      &   01      &   0 \\
                11      &   10      &   0 \\
                11      &   11      &   1 \\ \hline
            \end{tabular}
        \end{center}
    \end{solution}

    %=================== Problem 5 ===================%
    \begin{problem}
        Provide the whole truth table for the Min3 circuit discussed in the lecture (Slide 37) for the secure string matching problem. We assume that S and T, each has only 3 characters.
    \end{problem}

    \begin{solution}
        As S and T of length 3, the bits required for V(i,j) is $\lceil log_2 (3+1)\rceil = 2$;
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|}[H]
                V(i-1,j) & V(i, j-1) & V(i-1,j-1) & $\delta$(S[i], T[j]) & V(i,j) \\ \hline
                00 	&	 00 	&	 00 	&	 0 	&	 00 \\ 
                00 	&	 00 	&	 00 	&	 1 	&	 01 \\ \hline
                00 	&	 00 	&	 01 	&	 0 	&	 01 \\ 
                00 	&	 00 	&	 01 	&	 1 	&	 01 \\ \hline
                00 	&	 00 	&	 10 	&	 0 	&	 01 \\ 
                00 	&	 00 	&	 10 	&	 1 	&	 01 \\ \hline
                00 	&	 01 	&	 00 	&	 0 	&	 00 \\ 
                00 	&	 01 	&	 00 	&	 1 	&	 01 \\ \hline
                00 	&	 01 	&	 01 	&	 0 	&	 01 \\ 
                00 	&	 01 	&	 01 	&	 1 	&	 01 \\ \hline
                00 	&	 01 	&	 10 	&	 0 	&	 01 \\ 
                00 	&	 01 	&	 10 	&	 1 	&	 01 \\ \hline
                00 	&	 10 	&	 00 	&	 0 	&	 00 \\ 
                00 	&	 10 	&	 00 	&	 1 	&	 01 \\ \hline
                00 	&	 10 	&	 01 	&	 0 	&	 01 \\ 
                00 	&	 10 	&	 01 	&	 1 	&	 01 \\ \hline
                00 	&	 10 	&	 10 	&	 0 	&	 01 \\ 
                00 	&	 10 	&	 10 	&	 1 	&	 01 \\ \hline
                01 	&	 00 	&	 00 	&	 0 	&	 00 \\ 
                01 	&	 00 	&	 00 	&	 1 	&	 01 \\ \hline
                01 	&	 00 	&	 01 	&	 0 	&	 01 \\ 
                01 	&	 00 	&	 01 	&	 1 	&	 01 \\ \hline
                01 	&	 00 	&	 10 	&	 0 	&	 01 \\ 
                01 	&	 00 	&	 10 	&	 1 	&	 01 \\ \hline
                01 	&	 01 	&	 00 	&	 0 	&	 00 \\ 
                01 	&	 01 	&	 00 	&	 1 	&	 01 \\ \hline
                01 	&	 01 	&	 01 	&	 0 	&	 01 \\ 
                01 	&	 01 	&	 01 	&	 1 	&	 10 \\ \hline
                01 	&	 01 	&	 10 	&	 0 	&	 10 \\ 
                01 	&	 01 	&	 10 	&	 1 	&	 10 \\ \hline
                01 	&	 10 	&	 00 	&	 0 	&	 00 \\ 
                01 	&	 10 	&	 00 	&	 1 	&	 01 \\ \hline
                01 	&	 10 	&	 01 	&	 0 	&	 01 \\ 
                01 	&	 10 	&	 01 	&	 1 	&	 10 \\ \hline
                01 	&	 10 	&	 10 	&	 0 	&	 10 \\ 
                01 	&	 10 	&	 10 	&	 1 	&	 10 \\ \hline
                10 	&	 00 	&	 00 	&	 0 	&	 00 \\ 
                10 	&	 00 	&	 00 	&	 1 	&	 01 \\ \hline
                10 	&	 00 	&	 01 	&	 0 	&	 01 \\ 
                10 	&	 00 	&	 01 	&	 1 	&	 01 \\ \hline
                10 	&	 00 	&	 10 	&	 0 	&	 01 \\ 
                10 	&	 00 	&	 10 	&	 1 	&	 01 \\ \hline
                10 	&	 01 	&	 00 	&	 0 	&	 00 \\ 
                10 	&	 01 	&	 00 	&	 1 	&	 01 \\ \hline
                10 	&	 01 	&	 01 	&	 0 	&	 01 \\ 
                10 	&	 01 	&	 01 	&	 1 	&	 10 \\ \hline
                10 	&	 01 	&	 10 	&	 0 	&	 10 \\ 
                10 	&	 01 	&	 10 	&	 1 	&	 10 \\ \hline
                10 	&	 10 	&	 00 	&	 0 	&	 00 \\ 
                10 	&	 10 	&	 00 	&	 1 	&	 01 \\ \hline
                10 	&	 10 	&	 01 	&	 0 	&	 01 \\ 
                10 	&	 10 	&	 01 	&	 1 	&	 10 \\ \hline
                10 	&	 10 	&	 10 	&	 0 	&	 10 \\ 
                10 	&	 10 	&	 10 	&	 1 	&	 11 \\ \hline
            \end{tabular}
        \end{center}
    \end{solution}

    %=================== Problem 6 ===================%
    \begin{problem}
        Extend the meet-in-the-middle attack to 3DES with 3 different keys and give the complexity for the attack.
    \end{problem}

    \begin{solution}
        Firstly we should elaborate the 3DES scheme with 3 different keys:
        \begin{gather*}
            C = E_{K3}[D_{K2}[E_{K1}(P)]]
            \\
            P = D_{K1}[E_{K2}[D_{K3}(C)]]
        \end{gather*}
        Then for meet-in-middle attack, we should focus on the following middle encryption results:
        $$
            D_{K3} = D_{K2}[E_{K1}(P)]
        $$
        Attacker coudl firstly store encryption results with respect to $K2$ and store the resutls in table $T[D_{K2}[P], K2]$ (the storage space is $2^{56}$). Then the attacker should try the decryption with repect to $(K3, C)$ to find the entry in the previous table, which would cost $2^{56+56} = 2^{112}$ operations for the composition of key $K1, K2$.\\
        The complexity for this attack costs total $2^{112} + 2^{56} \approx 2^{112}$ operations on encryption and decryption tries.

        Reference:
        {[1] https://crypto.stackexchange.com/questions/6345/why-is-triple-des-using-three-different-keys-vulnerable-to-a-meet-in-the-middle} \\
        {[2] http://stephanemoore.com/pdf/meetinthemiddle.pdf}
    \end{solution}

    %=================== Problem 7 ===================%
    \begin{problem}
        Provide a real-life example that a chosen-ciphertext attack is feasible.
    \end{problem}

    \begin{solution}
        CCA would be feasible for any public key encryption scheme, cause public key is known to everyone. That means attacker could always get decryptions of the chosen ciphertext with the public key, so CCA is feasible in real-life. 
    \end{solution}

    %=================== Problem 8 ===================%
    \begin{problem}
        Comment (with an example) that the modified one-time-pad scheme II using a pseudorandom function cannot solve the problem of \textbf{message integrity}.
    \end{problem}

    \begin{solution}
        For the modeified one-time-pad scheme II, the message integrity check should follow the scheme: the sender encrypt message $m$ with $I=(r, F_k(r) \oplus m)$, then send $(m, I)$ to receiver. At receiver side, calculating $m'=I \oplus F_k(r)$; if $m'=m$ then the integrity check pass, otherwise it's not the original message.
        \\
        However, anyone in the middle could modify the pair $(m, I)$ with $(m \oplus c, I \oplus c)$ and also pass the integrity examination at the receiver side. So this scheme could not guarantee message integrity.
    \end{solution}

    %=================== Problem 9 ===================%
    \begin{problem}
        {[Exercise 3.10 of the reference text]} Let G be a pseudorandom generator and define G'(s) to be the output of G truncated to n bits (where $|s|=n$). Prove that the function $F_k(x)=G'(k) \oplus x$ is not pseudorandom.
    \end{problem}

    \begin{solution}
        To prove that the function $F_k(\cdot)$ is not pseudorandom, is equaivalent to the following expression: for a distinguisher $D$, it could not distinguish $F_k(\cdot)$ with a random function $f(\cdot)$ given any two input $x$ and $x'$ within polynomial time. \\
        Firstly for the pseudorandom function $F_k(\cdot)$, the distinguisher could have:
        $$
            y = G'(k) \oplus x, y' = G'(k)
        $$
        then we find that $y \oplus y' = x \oplus x'$ with probability equals to 1.\\
        But for a real random function $f(\cdot)$, we coudl only find $y \oplus y' = x \oplus x'$ when they are exactly the same which is probability $2^{-n}$. Therefore we could find non-negligible probability with $1 - \frac{1}{2^n}$ between the two functions. We come to conclude that the function $F_k(x)$ is not pseudorandom.

        Reference: \\
        {[1] http://www.cs.fsu.edu/\texttt{\~{}}burmeste/cis5371/quiz/HA3-sol.pdf}
    \end{solution}

    %=================== Problem 10 ===================%
    \begin{problem}
        Consider the following public-key scheme. The public key is $(G, p, g, h)$ and the private key is $x$, generated exactly as in the Elgamal encryption scheme, where $h=g^x$. In order to encrypt a bit $b$, the sender does the following.

        \begin{enumerate}[label=(\alph*)]
            \item If $b=0$, then choose a random y from $Z_q^*$ and compute $c_1=g^y$ and $c_2=h^y$. The ciphertext if $(c_1, c_2)$.
            \item If $b=1$, then choose independent random $y$, $z$ from $Z_q^*$, compute $c_1=g^y$ and $c_2=g^z$, and set the ciphertext equal to $(c_1, c_2)$.
        \end{enumerate}

        Show that it is possible to decrypt efficiently given knowledge of $x$.
    \end{problem}

    \begin{solution}
        As following the ElGamal encryption scheme, the decryption side could calculate $m' = c_2 \times (c_1^x)^{-1}$ to tell the bit $b$;\\
        For case (a), we have $m' = h^y \times g^{-xy} = g^{xy} \times g^{-xy} = 1$; for case (b), we have $m' = g^{xz} \times g^{-xy}$ which should be random.
        Then we could easily obtain bit $b$ with knowledge of $x$ by:
        $$
            b = \begin{cases}
                1, &\text{if $m'$=1} \\
                0, &\text{otherwise}
            \end{cases}
        $$
        Reference:\\
        {[1] https://en.wikipedia.org/wiki/ElGamal\_encryption}
    \end{solution}
\end{document}